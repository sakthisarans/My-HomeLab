---
# ansible-galaxy collection install community.general

# --- Play 1: Common setup and SSH ---
- name: Common setup and SSH install
  hosts: k8s-cluster
  become: true
  vars_files:
    - vars.yml
  tags: [common, ssh]
  tasks:
    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: true
        cache_valid_time: 3600

    - name: Upgrade system packages non-interactively
      ansible.builtin.apt:
        upgrade: dist
        autoremove: true
        force: true

    - name: Install essential packages
      ansible.builtin.apt:
        name:
          - openssh-server
          - curl
          - ca-certificates
        state: present

    - name: Ensure SSH service is running
      ansible.builtin.systemd:
        name: ssh
        state: started
        enabled: true

# --- Play 2: Install and configure MicroK8s ---
- name: Install and configure MicroK8s
  hosts: k8s-cluster
  become: true
  vars_files:
    - vars.yml
  tags: [microk8s]
  tasks:
    - name: Ensure snapd is installed
      ansible.builtin.apt:
        name: snapd
        state: present
        update_cache: true

    - name: Install MicroK8s
      community.general.snap:
        name: microk8s
        classic: true
        state: present
        channel: "{{ microk8s_channel }}"

    - name: Add user to microk8s group
      ansible.builtin.user:
        name: "{{ ansible_user }}"
        groups: microk8s
        append: true

    - name: Wait until MicroK8s is ready
      ansible.builtin.command: microk8s status --wait-ready
      register: microk8s_status
      retries: 10
      delay: 10
      changed_when: false
      until: microk8s_status.rc == 0

    - name: Enable MicroK8s add-ons individually
      loop:
        - dns
        - storage
        - "metallb:{{ metallb_range }}"
        - metrics-server
        - dashboard
        - ingress
        - rbac
      loop_control:
        loop_var: addon
      ansible.builtin.command: microk8s enable {{ addon }}
      register: addon_status
      changed_when: "'already enabled' not in addon_status.stdout"
      failed_when: "'error' in addon_status.stdout.lower()"

# --- Play 3: Generate join token ---
- name: Generate join token for workers
  hosts: k8s-master
  become: true
  run_once: true
  vars_files:
    - vars.yml
  tags: [microk8s, join]
  tasks:
    - name: Generate join command
      ansible.builtin.command: microk8s add-node
      register: addnode_output
      changed_when: false
    - name: Extract join command
      ansible.builtin.set_fact:
        microk8s_join: "{{ addnode_output.stdout | regex_search('join[^\\n]*', multiline=True) | first }}"

    - name: Ensure join command was found
      ansible.builtin.fail:
        msg: "Join command not found in add-node output"
      when: microk8s_join is not defined or microk8s_join == ""

# --- Play 4: Join worker nodes ---
- name: Join worker nodes to cluster
  hosts: k8s-workers
  become: true
  vars_files:
    - vars.yml
  tags: [microk8s, join]
  tasks:
    - name: Run join command on worker
      ansible.builtin.command: "microk8s {{ hostvars[groups['k8s-master'][0]].microk8s_join }}" # noqa: inline-env-var
      register: join_result
      retries: 5
      delay: 10
      changed_when: "'already joined' not in join_result.stdout"
      until: join_result.rc == 0
      args:
        warn: false

# --- Play 5: Install Cloudflared tunnels ---
- name: Install Cloudflared tunnels
  hosts: k8s-master
  become: true
  vars_files:
    - vars.yml
  tags: [cloudflared]
  tasks:
    - name: Validate tunnel IDs provided
      ansible.builtin.assert:
        that:
          - tunnel1_id is defined
          - tunnel2_id is defined
        fail_msg: "Please set tunnel1_id and tunnel2_id in vars.yml or via -e."

    - name: Detect CPU architecture
      ansible.builtin.set_fact:
        cf_arch: "{{ cloudflared_arch_map.get(ansible_architecture, 'amd64') }}"

    - name: Download Cloudflared package if missing
      ansible.builtin.get_url:
        url: "{{ cloudflared_release_base }}/cloudflared-linux-{{ cf_arch }}.deb"
        dest: /tmp/cloudflared.deb
        mode: '0755'
      register: cloudflared_download
      changed_when: cloudflared_download is succeeded

    - name: Install Cloudflared
      ansible.builtin.apt:
        deb: /tmp/cloudflared.deb
        state: present

    - name: Create systemd services for Cloudflared tunnels
      loop: "{{ cloudflare_tunnels }}"
      loop_control:
        loop_var: tunnel
      ansible.builtin.copy:
        dest: "/etc/systemd/system/cloudflared-{{ tunnel.name }}.service"
        content: |
          [Unit]
          Description=Cloudflared Tunnel {{ tunnel.name }}
          After=network.target

          [Service]
          ExecStart={{ tunnel.cmd }}
          Restart=on-failure
          User=root

          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Reload systemd daemon once
      ansible.builtin.systemd:
        daemon-reload: true
      changed_when: false

    - name: Enable and start Cloudflared services
      loop: "{{ cloudflare_tunnels }}"
      loop_control:
        loop_var: tunnel
      ansible.builtin.systemd:
        name: "cloudflared-{{ tunnel.name }}.service"
        enabled: true
        state: started

# --- Optional Cleanup ---
- name: Cleanup temporary files
  hosts: k8s-master
  become: true
  tasks:
    - name: Remove cloudflared .deb
      ansible.builtin.file:
        path: /tmp/cloudflared.deb
        state: absent

    - name: Remove cloned repo folder
      ansible.builtin.file:
        path: "{{ repo_dir }}"
        state: absent
